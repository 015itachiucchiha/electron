From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Samuel Attard <marshallofsound@electronjs.org>
Date: Mon, 6 Jul 2020 16:58:29 -0700
Subject: chore: add crashpad patches for apple silicon

These will appear upstream shortly and when they do we can remove this patch.

diff --git a/third_party/crashpad/crashpad/client/simulate_crash_mac.cc b/third_party/crashpad/crashpad/client/simulate_crash_mac.cc
index 8d6e8bd9286f50db96d45c39e3359acc446dc94b..87ba479ec3c0610735efe221f77e60a1a344ad6f 100644
--- a/third_party/crashpad/crashpad/client/simulate_crash_mac.cc
+++ b/third_party/crashpad/crashpad/client/simulate_crash_mac.cc
@@ -95,6 +95,11 @@ bool DeliverException(thread_t thread,
       state_count = cpu_context.tsh.count;
       break;
 #endif
+#elif defined(ARCH_CPU_ARM64)
+    case ARM_THREAD_STATE64:
+      state = reinterpret_cast<ConstThreadState>(&cpu_context.ts_64);
+      state_count = cpu_context.ash.count;
+      break;
 #else
 #error Port to your CPU architecture
 #endif
diff --git a/third_party/crashpad/crashpad/client/simulate_crash_mac_test.cc b/third_party/crashpad/crashpad/client/simulate_crash_mac_test.cc
index c2f4c20496ab59036f2e9c323506a8367cd1b0c0..8e9c5d42913f97a9aad5bdd24098c68bd04f5ee4 100644
--- a/third_party/crashpad/crashpad/client/simulate_crash_mac_test.cc
+++ b/third_party/crashpad/crashpad/client/simulate_crash_mac_test.cc
@@ -200,6 +200,27 @@ class TestSimulateCrashMac final : public MachMultiprocess,
         case x86_DEBUG_STATE64:
           EXPECT_EQ(old_state_count, x86_DEBUG_STATE64_COUNT);
           break;
+#elif defined(ARCH_CPU_ARM64)
+        case ARM_UNIFIED_THREAD_STATE: {
+            EXPECT_EQ(old_state_count, ARM_UNIFIED_THREAD_STATE_COUNT);
+            const arm_unified_thread_state* state =
+                reinterpret_cast<const arm_unified_thread_state*>(old_state);
+            switch (state->ash.flavor) {
+              case ARM_THREAD_STATE32:
+                EXPECT_EQ(implicit_cast<uint32_t>(state->ash.count),
+                          implicit_cast<uint32_t>(ARM_THREAD_STATE32_COUNT));
+                break;
+              case ARM_THREAD_STATE64:
+                EXPECT_EQ(implicit_cast<uint32_t>(state->ash.count),
+                          implicit_cast<uint32_t>(ARM_THREAD_STATE64_COUNT));
+                break;
+              default:
+                ADD_FAILURE() << "unexpected ash.flavor " << state->ash.flavor;
+                break;
+            }
+            break;
+        }
+        // FIXME: Check other flavors.
 #else
 #error Port to your CPU architecture
 #endif
@@ -338,6 +359,9 @@ TEST(SimulateCrash, SimulateCrash) {
       x86_FLOAT_STATE64,
       x86_DEBUG_STATE64,
 #endif
+#elif defined(ARCH_CPU_ARM64)
+      ARM_UNIFIED_THREAD_STATE,
+      // FIXME: Check other flavors.
 #else
 #error Port to your CPU architecture
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/mac/cpu_context_mac.cc b/third_party/crashpad/crashpad/snapshot/mac/cpu_context_mac.cc
index 6e2950a506ccb375cf052898119a10cb93170448..61604c5fe628e48e4a23bf3ea72fdcfae3d52241 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/cpu_context_mac.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/cpu_context_mac.cc
@@ -569,4 +569,111 @@ void InitializeCPUContextARM64(CPUContextARM64* context,
 
 #endif
 
+#if defined(ARCH_CPU_ARM64)
+
+namespace {
+
+void InitializeCPUContextARM64Thread(
+    CPUContextARM64* context, const arm_thread_state64_t* arm_thread_state64) {
+  memcpy(&context->regs, arm_thread_state64->__x, sizeof(arm_thread_state64->__x));
+  context->regs[29] = arm_thread_state64_get_fp(*arm_thread_state64);
+  context->regs[30] = arm_thread_state64_get_lr(*arm_thread_state64);
+  context->sp = arm_thread_state64_get_sp(*arm_thread_state64);
+  context->pc = arm_thread_state64_get_pc(*arm_thread_state64);
+  context->spsr = arm_thread_state64->__cpsr;
+}
+
+void InitializeCPUContextARM64Neon(
+    CPUContextARM64* context, const arm_neon_state64_t* arm_neon_state64) {
+  memcpy(&context->fpsimd,
+         arm_neon_state64->__v,
+         sizeof(context->fpsimd));
+  context->fpsr = arm_neon_state64->__fpsr;
+  context->fpcr = arm_neon_state64->__fpcr;
+}
+
+thread_state_flavor_t InitializeCPUContextARM64Flavor(
+    CPUContextARM64* context,
+    thread_state_flavor_t flavor,
+    ConstThreadState state,
+    mach_msg_type_number_t state_count) {
+  mach_msg_type_number_t expected_state_count;
+  switch (flavor) {
+    case ARM_THREAD_STATE64:
+      expected_state_count = ARM_THREAD_STATE64_COUNT;
+      break;
+    case ARM_NEON_STATE64:
+      expected_state_count = ARM_NEON_STATE64_COUNT;
+      break;
+    case THREAD_STATE_NONE:
+      expected_state_count = 0;
+      break;
+    default:
+      LOG(WARNING) << "unhandled flavor " << flavor;
+      return THREAD_STATE_NONE;
+  }
+
+  if (state_count < expected_state_count) {
+    LOG(WARNING) << "expected state_count " << expected_state_count
+                 << " for flavor " << flavor << ", observed " << state_count;
+    return THREAD_STATE_NONE;
+  }
+
+  switch (flavor) {
+    case ARM_THREAD_STATE64: {
+      const arm_thread_state64_t* arm_thread_state64 =
+          reinterpret_cast<const arm_thread_state64_t*>(state);
+      InitializeCPUContextARM64Thread(context, arm_thread_state64);
+      return flavor;
+    }
+
+    case ARM_NEON_STATE64: {
+      const arm_neon_state64_t* arm_neon_state64 =
+          reinterpret_cast<const arm_neon_state64_t*>(state);
+      InitializeCPUContextARM64Neon(context, arm_neon_state64);
+      return flavor;
+    }
+
+    case THREAD_STATE_NONE: {
+      // This may happen without error when called without exception-style
+      // flavor data, or even from an exception handler when the exception
+      // behavior is EXCEPTION_DEFAULT.
+      return flavor;
+    }
+
+    default: {
+      NOTREACHED();
+      return THREAD_STATE_NONE;
+    }
+  }
+}
+
+}  // namespace
+
+namespace internal {
+
+void InitializeCPUContextARM64(CPUContextARM64* context,
+                               thread_state_flavor_t flavor,
+                               ConstThreadState state,
+                               mach_msg_type_number_t state_count,
+                               const arm_thread_state64_t* arm_thread_state64,
+                               const arm_neon_state64_t* arm_neon_state64) {
+  thread_state_flavor_t set_flavor = THREAD_STATE_NONE;
+  if (flavor != THREAD_STATE_NONE) {
+    set_flavor =
+        InitializeCPUContextARM64Flavor(context, flavor, state, state_count);
+  }
+
+  if (set_flavor != ARM_THREAD_STATE64) {
+    InitializeCPUContextARM64Thread(context, arm_thread_state64);
+  }
+  if (set_flavor != ARM_NEON_STATE64) {
+    InitializeCPUContextARM64Neon(context, arm_neon_state64);
+  }
+}
+
+}  // namespace internal
+
+#endif
+
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/snapshot/mac/cpu_context_mac.h b/third_party/crashpad/crashpad/snapshot/mac/cpu_context_mac.h
index 05c035a1d0d8c241bfc065f4da640dd0dd8e775e..9b7b6a16e92888ab6fcd5f793745a195ecdb1651 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/cpu_context_mac.h
+++ b/third_party/crashpad/crashpad/snapshot/mac/cpu_context_mac.h
@@ -148,6 +148,17 @@ void InitializeCPUContextARM64(CPUContextARM64* context,
                                const arm_neon_state64_t* arm_neon_state64);
 #endif
 
+#if defined(ARCH_CPU_ARM64) || DOXYGEN
+
+void InitializeCPUContextARM64(CPUContextARM64* context,
+                               thread_state_flavor_t flavor,
+                               ConstThreadState state,
+                               mach_msg_type_number_t state_count,
+                               const arm_thread_state64_t* arm_thread_state64,
+                               const arm_neon_state64_t* arm_neon_state64);
+
+#endif
+
 }  // namespace internal
 }  // namespace crashpad
 
diff --git a/third_party/crashpad/crashpad/snapshot/mac/exception_snapshot_mac.cc b/third_party/crashpad/crashpad/snapshot/mac/exception_snapshot_mac.cc
index 8eefac9f39144d364af5ef9cf461d652f00f5435..49ddc691f0a0ea2fa8befbdd90ed3122ccda202d 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/exception_snapshot_mac.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/exception_snapshot_mac.cc
@@ -28,7 +28,11 @@ namespace internal {
 
 ExceptionSnapshotMac::ExceptionSnapshotMac()
     : ExceptionSnapshot(),
+#if defined(ARCH_CPU_X86_FAMILY)
       context_union_(),
+#elif defined(ARCH_CPU_ARM64)
+      context_arm64_(),
+#endif
       context_(),
       codes_(),
       thread_id_(0),
@@ -187,6 +191,15 @@ bool ExceptionSnapshotMac::Initialize(ProcessReaderMac* process_reader,
        exception_code_0_ == (VM_PROT_READ | VM_PROT_EXECUTE))) {
     code_1_is_exception_address = false;
   }
+#elif defined(ARCH_CPU_ARM64)
+  context_.architecture = kCPUArchitectureARM64;
+  context_.arm64 = &context_arm64_;
+  InitializeCPUContextARM64(context_.arm64,
+                            flavor,
+                            state,
+                            state_count,
+                            &thread->thread_context,
+                            &thread->float_context);
 #endif
 
   if (code_1_is_exception_address) {
diff --git a/third_party/crashpad/crashpad/snapshot/mac/exception_snapshot_mac.h b/third_party/crashpad/crashpad/snapshot/mac/exception_snapshot_mac.h
index 52ef519b44d909e74db16f08f2afa72c0ba12bde..9cdb1bab6b49dd6331f9a70164a4a07175e405f7 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/exception_snapshot_mac.h
+++ b/third_party/crashpad/crashpad/snapshot/mac/exception_snapshot_mac.h
@@ -84,6 +84,8 @@ class ExceptionSnapshotMac final : public ExceptionSnapshot {
     CPUContextX86 x86;
     CPUContextX86_64 x86_64;
   } context_union_;
+#elif defined(ARCH_CPU_ARM64)
+  CPUContextARM64 context_arm64_;
 #endif
   CPUContext context_;
   std::vector<uint64_t> codes_;
diff --git a/third_party/crashpad/crashpad/snapshot/mac/mach_o_image_annotations_reader_test.cc b/third_party/crashpad/crashpad/snapshot/mac/mach_o_image_annotations_reader_test.cc
index 8659a141a2ced8c005f385d0399634ff920eb458..73fb8f0499e1965f5d7c6bb60a3182116b628dc6 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/mach_o_image_annotations_reader_test.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/mach_o_image_annotations_reader_test.cc
@@ -112,9 +112,7 @@ class TestMachOImageAnnotationsReader final
         break;
 
       case kCrashModuleInitialization:
-        // This crash is triggered by __builtin_trap(), which shows up as
-        // SIGILL.
-        SetExpectedChildTermination(kTerminationSignal, SIGILL);
+        SetExpectedChildTerminationBuiltinTrap();
         break;
 
       case kCrashDyld:
@@ -245,14 +243,12 @@ class TestMachOImageAnnotationsReader final
       if (test_type_ == kCrashDyld) {
         static constexpr char kExpectedAnnotation[] =
             "could not load inserted library";
-        size_t expected_annotation_length = strlen(kExpectedAnnotation);
         bool found = false;
         for (const std::string& annotation : all_annotations_vector) {
           // Look for the expectation as a leading substring, because the actual
           // string will contain the library’s pathname and, on OS X 10.9 and
           // later, a reason.
-          if (annotation.substr(0, expected_annotation_length) ==
-                  kExpectedAnnotation) {
+          if (annotation.find(kExpectedAnnotation) != std::string::npos) {
             found = true;
             break;
           }
diff --git a/third_party/crashpad/crashpad/snapshot/mac/mach_o_image_reader_test.cc b/third_party/crashpad/crashpad/snapshot/mac/mach_o_image_reader_test.cc
index 625f8a70dacebce66548958908b92d772385205c..53826bfcff58c36764f24795a504e32456bffecc 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/mach_o_image_reader_test.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/mach_o_image_reader_test.cc
@@ -68,6 +68,8 @@ using Nlist = struct nlist;
 constexpr int kCPUType = CPU_TYPE_X86_64;
 #elif defined(ARCH_CPU_X86)
 constexpr int kCPUType = CPU_TYPE_X86;
+#elif defined(ARCH_CPU_ARM64)
+constexpr int kCPUType = CPU_TYPE_ARM64;
 #endif
 
 // Verifies that |expect_section| and |actual_section| agree.
diff --git a/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac.cc b/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac.cc
index 61dc3a1f3ae73a4d59d1df5235cb33fb4c01dbf3..181ca16d7ac956a9d8c0ff341df430f40c622ad7 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac.cc
@@ -280,6 +280,15 @@ void ProcessReaderMac::InitializeThreads() {
         Is64Bit() ? x86_DEBUG_STATE64 : x86_DEBUG_STATE32;
     mach_msg_type_number_t debug_state_count =
         Is64Bit() ? x86_DEBUG_STATE64_COUNT : x86_DEBUG_STATE32_COUNT;
+#elif defined(ARCH_CPU_ARM64)
+    const thread_state_flavor_t kThreadStateFlavor = ARM_THREAD_STATE64;
+    mach_msg_type_number_t thread_state_count = ARM_THREAD_STATE64_COUNT;
+
+    const thread_state_flavor_t kFloatStateFlavor = ARM_NEON_STATE64;
+    mach_msg_type_number_t float_state_count = ARM_NEON_STATE64_COUNT;
+
+    const thread_state_flavor_t kDebugStateFlavor = ARM_DEBUG_STATE64;
+    mach_msg_type_number_t debug_state_count = ARM_DEBUG_STATE64_COUNT;
 #endif
 
     kr = thread_get_state(
@@ -366,6 +375,8 @@ void ProcessReaderMac::InitializeThreads() {
     mach_vm_address_t stack_pointer = Is64Bit()
                                           ? thread.thread_context.t64.__rsp
                                           : thread.thread_context.t32.__esp;
+#elif defined(ARCH_CPU_ARM64)
+    mach_vm_address_t stack_pointer = arm_thread_state64_get_sp(thread.thread_context);
 #endif
 
     thread.stack_region_address =
diff --git a/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac.h b/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac.h
index 9feb8b071fa5507206f0d16581e7e942f6285b48..1dc244576a4ae7e57b1b91df7791c26c7796ab97 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac.h
+++ b/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac.h
@@ -55,6 +55,10 @@ class ProcessReaderMac {
       x86_debug_state64_t d64;
       x86_debug_state32_t d32;
     };
+#elif defined(ARCH_CPU_ARM_FAMILY)
+    typedef arm_thread_state64_t ThreadContext;
+    typedef arm_neon_state64_t FloatContext;
+    typedef arm_debug_state64_t DebugContext;
 #endif
 
     Thread();
diff --git a/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac_test.cc b/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac_test.cc
index 2d64ff10a8c7d3d14784be643daa6852888bb5ef..49fa4785cfbef820209c131835fd9456bf2ec00c 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac_test.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac_test.cc
@@ -565,6 +565,10 @@ class ScopedOpenCLNoOpKernel {
   }
 
   void SetUp() {
+#if defined(ARCH_CPU_ARM64)
+    // FIXME: Make this test work in ARM64.
+    return;
+#endif
     cl_platform_id platform_id;
     cl_int rv = clGetPlatformIDs(1, &platform_id, nullptr);
     ASSERT_EQ(rv, CL_SUCCESS) << "clGetPlatformIDs";
@@ -640,6 +644,10 @@ class ScopedOpenCLNoOpKernel {
 // OpenCL kernels that run on the CPU do not result in cl_kernels images
 // appearing on that OS version.
 bool ExpectCLKernels() {
+#if defined(ARCH_CPU_ARM64)
+    // FIXME: Make this test work in ARM64.
+    return false;
+#endif
 #if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7
   return true;
 #else
diff --git a/third_party/crashpad/crashpad/snapshot/mac/system_snapshot_mac.cc b/third_party/crashpad/crashpad/snapshot/mac/system_snapshot_mac.cc
index 5410be085ea81fc284c1364ba14499a2caf5d918..b8b4ea9da18b3dfed7dc5141df09317d99096995 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/system_snapshot_mac.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/system_snapshot_mac.cc
@@ -157,6 +157,8 @@ CPUArchitecture SystemSnapshotMac::GetCPUArchitecture() const {
 #if defined(ARCH_CPU_X86_FAMILY)
   return process_reader_->Is64Bit() ? kCPUArchitectureX86_64
                                     : kCPUArchitectureX86;
+#elif defined(ARCH_CPU_ARM64)
+  return kCPUArchitectureARM64;
 #else
 #error port to your architecture
 #endif
@@ -174,6 +176,9 @@ uint32_t SystemSnapshotMac::CPURevision() const {
   uint8_t stepping = CastIntSysctlByName<uint8_t>("machdep.cpu.stepping", 0);
 
   return (family << 16) | (model << 8) | stepping;
+#elif defined(ARCH_CPU_ARM64)
+  // FIXME: Consider exposing SOC details here.
+  return 0;
 #else
 #error port to your architecture
 #endif
@@ -187,7 +192,7 @@ uint8_t SystemSnapshotMac::CPUCount() const {
 std::string SystemSnapshotMac::CPUVendor() const {
   INITIALIZATION_STATE_DCHECK_VALID(initialized_);
 
-#if defined(ARCH_CPU_X86_FAMILY)
+#if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM64)
   return ReadStringSysctlByName("machdep.cpu.vendor");
 #else
 #error port to your architecture
diff --git a/third_party/crashpad/crashpad/snapshot/mac/system_snapshot_mac_test.cc b/third_party/crashpad/crashpad/snapshot/mac/system_snapshot_mac_test.cc
index 2b665924d5ea08fe2714de06f3b766d731bc39e8..2c1a322bc08b522d9a3cf95bcf2510806484d767 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/system_snapshot_mac_test.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/system_snapshot_mac_test.cc
@@ -69,6 +69,8 @@ TEST_F(SystemSnapshotMacTest, GetCPUArchitecture) {
   EXPECT_EQ(cpu_architecture, kCPUArchitectureX86);
 #elif defined(ARCH_CPU_X86_64)
   EXPECT_EQ(cpu_architecture, kCPUArchitectureX86_64);
+#elif defined(ARCH_CPU_ARM64)
+  EXPECT_EQ(cpu_architecture, kCPUArchitectureARM64);
 #else
 #error port to your architecture
 #endif
@@ -87,6 +89,8 @@ TEST_F(SystemSnapshotMacTest, CPUVendor) {
   if (cpu_vendor != "GenuineIntel" && cpu_vendor != "AuthenticAMD") {
     FAIL() << "cpu_vendor " << cpu_vendor;
   }
+#elif defined(ARCH_CPU_ARM64)
+  EXPECT_EQ(cpu_vendor, "");
 #else
 #error port to your architecture
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/mac/thread_snapshot_mac.cc b/third_party/crashpad/crashpad/snapshot/mac/thread_snapshot_mac.cc
index ddb4def4514236753430c14b2f55adf4ee370b8a..f2f9bb83bafd9b1837f09bae1d7b869a2bec3259 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/thread_snapshot_mac.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/thread_snapshot_mac.cc
@@ -23,7 +23,11 @@ namespace internal {
 
 ThreadSnapshotMac::ThreadSnapshotMac()
     : ThreadSnapshot(),
+#if defined(ARCH_CPU_X86_FAMILY)
       context_union_(),
+#elif defined(ARCH_CPU_ARM64)
+      context_arm64_(),
+#endif
       context_(),
       stack_(),
       thread_id_(0),
@@ -75,6 +79,15 @@ bool ThreadSnapshotMac::Initialize(
                             &process_reader_thread.float_context.f32,
                             &process_reader_thread.debug_context.d32);
   }
+#elif defined(ARCH_CPU_ARM64)
+  context_.architecture = kCPUArchitectureARM64;
+  context_.arm64 = &context_arm64_;
+  InitializeCPUContextARM64(context_.arm64,
+                            THREAD_STATE_NONE,
+                            nullptr,
+                            0,
+                            &process_reader_thread.thread_context,
+                            &process_reader_thread.float_context);
 #endif
 
   INITIALIZATION_STATE_SET_VALID(initialized_);
diff --git a/third_party/crashpad/crashpad/snapshot/mac/thread_snapshot_mac.h b/third_party/crashpad/crashpad/snapshot/mac/thread_snapshot_mac.h
index 946b0085c1a30af352a4f60bae3e71a6967edb61..eb06e3e28ad5f317cb374f49b1149fe983b71a93 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/thread_snapshot_mac.h
+++ b/third_party/crashpad/crashpad/snapshot/mac/thread_snapshot_mac.h
@@ -68,6 +68,8 @@ class ThreadSnapshotMac final : public ThreadSnapshot {
     CPUContextX86 x86;
     CPUContextX86_64 x86_64;
   } context_union_;
+#elif defined(ARCH_CPU_ARM64)
+  CPUContextARM64 context_arm64_;
 #endif
   CPUContext context_;
   MemorySnapshotGeneric stack_;
diff --git a/third_party/crashpad/crashpad/util/mac/mac_util_test.mm b/third_party/crashpad/crashpad/util/mac/mac_util_test.mm
index 546c6286964ee0e3a9c9ed7ecd443ebf9c7759e1..06bf47c3af9b3aba8c6485cf8c1f76b61e410db9 100644
--- a/third_party/crashpad/crashpad/util/mac/mac_util_test.mm
+++ b/third_party/crashpad/crashpad/util/mac/mac_util_test.mm
@@ -135,7 +135,9 @@ void SwVers(NSString* argument, std::string* output) {
   MacModelAndBoard(&model, &board);
 
   EXPECT_FALSE(model.empty());
+#if !defined(ARCH_CPU_ARM64)
   EXPECT_FALSE(board.empty());
+#endif
 }
 
 }  // namespace
diff --git a/third_party/crashpad/crashpad/util/mac/service_management_test.mm b/third_party/crashpad/crashpad/util/mac/service_management_test.mm
index 0bec3366f9094b9b42f12ddf1bf6d4134a7f9b20..374f6ddf7a62d768efb587c4828db61037beca56 100644
--- a/third_party/crashpad/crashpad/util/mac/service_management_test.mm
+++ b/third_party/crashpad/crashpad/util/mac/service_management_test.mm
@@ -48,7 +48,7 @@ void ExpectProcessIsRunning(pid_t pid, std::string& last_arg) {
     // If the process is in the middle of calling exec, process_info.Arguments()
     // may fail. Loop with a small retry delay while waiting for the expected
     // successful call.
-    int inner_tries = 10;
+    int inner_tries = 30;
     bool success;
     do {
       success = process_info.Arguments(&job_argv);
diff --git a/third_party/crashpad/crashpad/util/mach/exc_server_variants_test.cc b/third_party/crashpad/crashpad/util/mach/exc_server_variants_test.cc
index 553661e3cb9e8a546675a51a883783cd1e716ab4..572f964e93fa9ce1559c7b7d42cdc88b506e525e 100644
--- a/third_party/crashpad/crashpad/util/mach/exc_server_variants_test.cc
+++ b/third_party/crashpad/crashpad/util/mach/exc_server_variants_test.cc
@@ -975,8 +975,7 @@ class TestExcServerVariants : public MachMultiprocess,
         flavor_(flavor),
         state_count_(state_count),
         handled_(false) {
-    // This is how the __builtin_trap() in MachMultiprocessChild() appears.
-    SetExpectedChildTermination(kTerminationSignal, SIGILL);
+    SetExpectedChildTerminationBuiltinTrap();
   }
 
   // UniversalMachExcServer::Interface:
@@ -1180,6 +1179,10 @@ TEST(ExcServerVariants, ThreadStates) {
       {x86_THREAD_STATE, x86_THREAD_STATE_COUNT},
       {x86_FLOAT_STATE, x86_FLOAT_STATE_COUNT},
       {x86_EXCEPTION_STATE, x86_EXCEPTION_STATE_COUNT},
+#elif defined(ARCH_CPU_ARM64)
+      {ARM_THREAD_STATE64, ARM_THREAD_STATE64_COUNT},
+      {ARM_NEON_STATE64, ARM_NEON_STATE64_COUNT},
+      {ARM_EXCEPTION_STATE64, ARM_EXCEPTION_STATE64_COUNT},
 #else
 #error Port this test to your CPU architecture.
 #endif
diff --git a/third_party/crashpad/crashpad/util/mach/exception_ports_test.cc b/third_party/crashpad/crashpad/util/mach/exception_ports_test.cc
index 6dbc04ed170cdef710702adce346a8e930e0772c..ebcb4b6bd4d2efee9179f44ba56ddf1748453855 100644
--- a/third_party/crashpad/crashpad/util/mach/exception_ports_test.cc
+++ b/third_party/crashpad/crashpad/util/mach/exception_ports_test.cc
@@ -145,8 +145,7 @@ class TestExceptionPorts : public MachMultiprocess,
         who_crashes_(who_crashes),
         handled_(false) {
     if (who_crashes_ != kNobodyCrashes) {
-      // This is how the __builtin_trap() in Child::Crash() appears.
-      SetExpectedChildTermination(kTerminationSignal, SIGILL);
+      SetExpectedChildTerminationBuiltinTrap();
     }
   }
 
@@ -205,8 +204,14 @@ class TestExceptionPorts : public MachMultiprocess,
       int signal;
       ExcCrashRecoverOriginalException(code[0], nullptr, &signal);
 
-      // The child crashed with __builtin_trap(), which shows up as SIGILL.
+      // The child crashed with __builtin_trap(), which shows up as...
+#if defined(ARCH_CPU_ARM64)
+      // ...SIGTRAP.
+      EXPECT_EQ(signal, SIGTRAP);
+#else
+      // ...SIGILL.
       EXPECT_EQ(signal, SIGILL);
+#endif
     }
 
     EXPECT_EQ(AuditPIDFromMachMessageTrailer(trailer), 0);
diff --git a/third_party/crashpad/crashpad/util/mach/exception_types_test.cc b/third_party/crashpad/crashpad/util/mach/exception_types_test.cc
index da2c82223022b295b999d1195a5d0de9d8979128..d740491429d8cde3fe206def105e834a98065f8f 100644
--- a/third_party/crashpad/crashpad/util/mach/exception_types_test.cc
+++ b/third_party/crashpad/crashpad/util/mach/exception_types_test.cc
@@ -41,8 +41,11 @@ TEST(ExceptionTypes, ExcCrashRecoverOriginalException) {
       {0xb100002, EXC_BAD_ACCESS, KERN_PROTECTION_FAILURE, SIGSEGV},
       {0xa100002, EXC_BAD_ACCESS, KERN_PROTECTION_FAILURE, SIGBUS},
       {0xa100005, EXC_BAD_ACCESS, VM_PROT_READ | VM_PROT_EXECUTE, SIGBUS},
+#if defined(ARCH_CPU_X86_FAMILY)
       {0xa10000d, EXC_BAD_ACCESS, EXC_I386_GPFLT, SIGBUS},
+#endif
       {0x9100032, EXC_BAD_ACCESS, KERN_CODESIGN_ERROR, SIGKILL},
+#if defined(ARCH_CPU_X86_FAMILY)
       {0x4200001, EXC_BAD_INSTRUCTION, EXC_I386_INVOP, SIGILL},
       {0x420000b, EXC_BAD_INSTRUCTION, EXC_I386_SEGNPFLT, SIGILL},
       {0x420000c, EXC_BAD_INSTRUCTION, EXC_I386_STKFLT, SIGILL},
@@ -53,6 +56,7 @@ TEST(ExceptionTypes, ExcCrashRecoverOriginalException) {
       {0x5500007, EXC_SOFTWARE, EXC_I386_BOUND, SIGTRAP},
       {0x5600001, EXC_BREAKPOINT, EXC_I386_SGL, SIGTRAP},
       {0x5600002, EXC_BREAKPOINT, EXC_I386_BPT, SIGTRAP},
+#endif
       {0x0700080, EXC_SYSCALL, 128, 0},
       {0x0706000, EXC_SYSCALL, 0x6000, 0},
       {0x3000000, 0, 0, SIGQUIT},
@@ -142,8 +146,11 @@ TEST(ExceptionTypes, ExceptionCodeForMetrics) {
       ENCODE_EXC(EXC_BAD_ACCESS, KERN_INVALID_ADDRESS),
       ENCODE_EXC(EXC_BAD_ACCESS, KERN_PROTECTION_FAILURE),
       ENCODE_EXC(EXC_BAD_ACCESS, VM_PROT_READ | VM_PROT_EXECUTE),
+#if defined(ARCH_CPU_X86_FAMILY)
       ENCODE_EXC(EXC_BAD_ACCESS, EXC_I386_GPFLT),
+#endif
       ENCODE_EXC(EXC_BAD_ACCESS, KERN_CODESIGN_ERROR),
+#if defined(ARCH_CPU_X86_FAMILY)
       ENCODE_EXC(EXC_BAD_INSTRUCTION, EXC_I386_INVOP),
       ENCODE_EXC(EXC_BAD_INSTRUCTION, EXC_I386_SEGNPFLT),
       ENCODE_EXC(EXC_BAD_INSTRUCTION, EXC_I386_STKFLT),
@@ -154,6 +161,7 @@ TEST(ExceptionTypes, ExceptionCodeForMetrics) {
       ENCODE_EXC(EXC_SOFTWARE, EXC_I386_BOUND),
       ENCODE_EXC(EXC_BREAKPOINT, EXC_I386_SGL),
       ENCODE_EXC(EXC_BREAKPOINT, EXC_I386_BPT),
+#endif
       ENCODE_EXC(EXC_SYSCALL, 128),
       ENCODE_EXC(EXC_SYSCALL, 0x6000),
 #undef ENCODE_EXC
@@ -166,8 +174,11 @@ TEST(ExceptionTypes, ExceptionCodeForMetrics) {
       ENCODE_EXC_CRASH(EXC_BAD_ACCESS, KERN_INVALID_ADDRESS),
       ENCODE_EXC_CRASH(EXC_BAD_ACCESS, KERN_PROTECTION_FAILURE),
       ENCODE_EXC_CRASH(EXC_BAD_ACCESS, VM_PROT_READ | VM_PROT_EXECUTE),
+#if defined(ARCH_CPU_X86_FAMILY)
       ENCODE_EXC_CRASH(EXC_BAD_ACCESS, EXC_I386_GPFLT),
+#endif
       ENCODE_EXC_CRASH(EXC_BAD_ACCESS, KERN_CODESIGN_ERROR),
+#if defined(ARCH_CPU_X86_FAMILY)
       ENCODE_EXC_CRASH(EXC_BAD_INSTRUCTION, EXC_I386_INVOP),
       ENCODE_EXC_CRASH(EXC_BAD_INSTRUCTION, EXC_I386_SEGNPFLT),
       ENCODE_EXC_CRASH(EXC_BAD_INSTRUCTION, EXC_I386_STKFLT),
@@ -178,6 +189,7 @@ TEST(ExceptionTypes, ExceptionCodeForMetrics) {
       ENCODE_EXC_CRASH(EXC_SOFTWARE, EXC_I386_BOUND),
       ENCODE_EXC_CRASH(EXC_BREAKPOINT, EXC_I386_SGL),
       ENCODE_EXC_CRASH(EXC_BREAKPOINT, EXC_I386_BPT),
+#endif
       ENCODE_EXC_CRASH(EXC_SYSCALL, 128),
       ENCODE_EXC_CRASH(EXC_SYSCALL, 0x6000),
 #undef ENCODE_EXC_CRASH
diff --git a/third_party/crashpad/crashpad/util/mach/mach_message_server_test.cc b/third_party/crashpad/crashpad/util/mach/mach_message_server_test.cc
index e3a3f94bd0ff294cdfde8244bb484ea729279e43..a7198da8a166777ab2e120d8e474dc27dff60837 100644
--- a/third_party/crashpad/crashpad/util/mach/mach_message_server_test.cc
+++ b/third_party/crashpad/crashpad/util/mach/mach_message_server_test.cc
@@ -309,7 +309,7 @@ class TestMachMessageServer : public MachMessageServer::Interface,
   // ensure that whatever buffer was allocated to receive a RequestMessage is
   // not large enough to receive a LargeRequestMessage.
   struct LargeRequestMessage : public RequestMessage {
-    uint8_t data[4 * PAGE_SIZE];
+    uint8_t data[4 * PAGE_MAX_SIZE];
   };
 
   struct ReplyMessage : public mig_reply_error_t {
diff --git a/third_party/crashpad/crashpad/util/mach/mig_gen.py b/third_party/crashpad/crashpad/util/mach/mig_gen.py
index dcbf8296d2adb0a5f6fa3ec0c58c74f79bf12f2d..b63e45a43dccfaf83b7c6df8098e382281f58780 100755
--- a/third_party/crashpad/crashpad/util/mach/mig_gen.py
+++ b/third_party/crashpad/crashpad/util/mach/mig_gen.py
@@ -23,7 +23,6 @@ import sys
 MigInterface = collections.namedtuple(
     'MigInterface', ['user_c', 'server_c', 'user_h', 'server_h'])
 
-
 def generate_interface(defs,
                        interface,
                        includes=[],
@@ -53,6 +52,8 @@ def generate_interface(defs,
         command.extend(['-arch', arch])
     if sdk is not None:
         command.extend(['-isysroot', sdk])
+    if arch is not None:
+        command.extend(['-arch', arch])
     for include in includes:
         command.extend(['-I' + include])
     command.append(defs)
@@ -86,6 +87,5 @@ def main(args):
                        parsed.clang_path, parsed.mig_path, parsed.migcom_path,
                        parsed.arch)
 
-
 if __name__ == '__main__':
     sys.exit(main(sys.argv[1:]))
diff --git a/third_party/crashpad/crashpad/util/misc/capture_context_mac.S b/third_party/crashpad/crashpad/util/misc/capture_context_mac.S
index f6acafbd3380e6de0e6cf17516913f922793dc4b..66afce49986b471a4d81e5b57c914650174ce21b 100644
--- a/third_party/crashpad/crashpad/util/misc/capture_context_mac.S
+++ b/third_party/crashpad/crashpad/util/misc/capture_context_mac.S
@@ -285,4 +285,56 @@ CAPTURECONTEXT_SYMBOL:
 
 .subsections_via_symbols
 
+#elif defined(__arm64__)
+
+// namespace crashpad {
+// void CaptureContext(arm_unified_thread_state_t* arm_thread_state);
+// }  // namespace crashpad
+#define CAPTURECONTEXT_SYMBOL __ZN8crashpad14CaptureContextEP24arm_unified_thread_state
+
+  .section __TEXT,__text,regular,pure_instructions
+  .private_extern CAPTURECONTEXT_SYMBOL
+  .globl CAPTURECONTEXT_SYMBOL
+  .balign 4, 0x0
+CAPTURECONTEXT_SYMBOL:
+
+  .cfi_startproc
+
+  stp x0, x1, [x0, #0x08]
+  stp x2, x3, [x0, #0x18]
+  stp x4, x5, [x0, #0x28]
+  stp x6, x7, [x0, #0x38]
+  stp x8, x9, [x0, #0x48]
+  stp x10, x11, [x0, #0x58]
+  stp x12, x13, [x0, #0x68]
+  stp x14, x15, [x0, #0x78]
+  stp x16, x17, [x0, #0x88]
+  stp x18, x19, [x0, #0x98]
+  stp x20, x21, [x0, #0xa8]
+  stp x22, x23, [x0, #0xb8]
+  stp x24, x25, [x0, #0xc8]
+  stp x26, x27, [x0, #0xd8]
+  stp x28, x29, [x0, #0xe8]
+  str x30, [x0, #0xf8]
+
+  mov x1, sp
+  str x1, [x0, #0x100]
+
+  str x30, [x0, #0x108]
+
+  mrs x1, NZCV
+  str x1, [x0, #0x110]
+
+  mov w1, #0x06 // ARM_THREAD_STATE64
+  str w1, [x0]
+
+  mov w1, #0x46 // ARM_THREAD_STATE64_COUNT
+  str w1, [x0, #0x04]
+
+  ldr x1, [x0, #0x10]
+
+  ret
+
+  .cfi_endproc
+
 #endif
diff --git a/third_party/crashpad/crashpad/util/net/http_transport_mac.mm b/third_party/crashpad/crashpad/util/net/http_transport_mac.mm
index a433bb357da5865144ade7d3663b1c9b36199f8e..8faa1b8a0444f903bf588ba085d60882e9d61162 100644
--- a/third_party/crashpad/crashpad/util/net/http_transport_mac.mm
+++ b/third_party/crashpad/crashpad/util/net/http_transport_mac.mm
@@ -91,6 +91,8 @@
     NSString* arch = @"i386";
 #elif defined(ARCH_CPU_X86_64)
     NSString* arch = @"x86_64";
+#elif defined(ARCH_CPU_ARM64)
+    NSString* arch = @"arm64";
 #else
 #error Port
 #endif
diff --git a/third_party/crashpad/crashpad/util/posix/signals.cc b/third_party/crashpad/crashpad/util/posix/signals.cc
index 7dbe10ebc224d02e20cce6dd45e2e6ed3f45c213..694203a85c5d4b58445234ec0b25634a97f898ff 100644
--- a/third_party/crashpad/crashpad/util/posix/signals.cc
+++ b/third_party/crashpad/crashpad/util/posix/signals.cc
@@ -208,6 +208,12 @@ bool Signals::WillSignalReraiseAutonomously(const siginfo_t* siginfo) {
   const int sig = siginfo->si_signo;
   const int code = siginfo->si_code;
 
+#if defined(OS_MACOSX) && defined(ARCH_CPU_ARM64)
+  if ((sig == SIGILL && code == ILL_ILLTRP) || (sig == SIGSEGV && code == SEGV_ACCERR)) {
+    return false;
+  }
+#endif
+
   // Only these signals can be generated from hardware faults and can re-raise
   // autonomously.
   return (sig == SIGBUS ||
diff --git a/third_party/crashpad/crashpad/util/process/process_memory_mac_test.cc b/third_party/crashpad/crashpad/util/process/process_memory_mac_test.cc
index d801bb149fed2e4874190ae4eda7684841997636..6cb6fae0b8e1e8db6de36c66c9866c0ca2d6b232 100644
--- a/third_party/crashpad/crashpad/util/process/process_memory_mac_test.cc
+++ b/third_party/crashpad/crashpad/util/process/process_memory_mac_test.cc
@@ -33,7 +33,7 @@ namespace {
 
 TEST(ProcessMemoryMac, ReadMappedSelf) {
   vm_address_t address = 0;
-  constexpr vm_size_t kSize = 4 * PAGE_SIZE;
+  const vm_size_t kSize = 4 * PAGE_SIZE;
   kern_return_t kr =
       vm_allocate(mach_task_self(), &address, kSize, VM_FLAGS_ANYWHERE);
   ASSERT_EQ(kr, KERN_SUCCESS) << MachErrorMessage(kr, "vm_allocate");
@@ -88,7 +88,7 @@ TEST(ProcessMemoryMac, ReadMappedSelf) {
 
 TEST(ProcessMemoryMac, ReadSelfUnmapped) {
   vm_address_t address = 0;
-  constexpr vm_size_t kSize = 2 * PAGE_SIZE;
+  const vm_size_t kSize = 2 * PAGE_SIZE;
   kern_return_t kr =
       vm_allocate(mach_task_self(), &address, kSize, VM_FLAGS_ANYWHERE);
   ASSERT_EQ(kr, KERN_SUCCESS) << MachErrorMessage(kr, "vm_allocate");
@@ -150,7 +150,7 @@ TEST(ProcessMemoryMac, ReadSelfUnmapped) {
 
 TEST(ProcessMemoryMac, ReadCStringSelfUnmapped) {
   vm_address_t address = 0;
-  constexpr vm_size_t kSize = 2 * PAGE_SIZE;
+  const vm_size_t kSize = 2 * PAGE_SIZE;
   kern_return_t kr =
       vm_allocate(mach_task_self(), &address, kSize, VM_FLAGS_ANYWHERE);
   ASSERT_EQ(kr, KERN_SUCCESS) << MachErrorMessage(kr, "vm_allocate");
@@ -259,7 +259,7 @@ TEST(ProcessMemoryMac, MappedMemoryDeallocates) {
   // This is the same but with a big buffer that’s definitely larger than a
   // single page. This makes sure that the whole mapped region winds up being
   // deallocated.
-  constexpr size_t kBigSize = 4 * PAGE_SIZE;
+  const size_t kBigSize = 4 * PAGE_SIZE;
   std::unique_ptr<char[]> big_buffer(new char[kBigSize]);
   test_address = FromPointerCast<mach_vm_address_t>(&big_buffer[0]);
   ASSERT_TRUE((mapped = memory.ReadMapped(test_address, kBigSize)));
